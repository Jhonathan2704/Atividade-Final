# -*- coding: utf-8 -*-
"""Atividade final - limpeza dos dados V1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Ta-fD59bdIx5xn2wjvfkKZAVWReqH3WS
"""

from google.colab import files
import pandas as pd
import zipfile
import io

# 1. FAZER UPLOAD DO ARQUIVO ZIP (Passo crucial)
print("Por favor, faça upload do arquivo ZIP contendo os datasets:")
uploaded = files.upload()

# 2. EXTRAIR OS ARQUIVOS DO ZIP
zip_filename = list(uploaded.keys())[0]  # Pega o nome do primeiro arquivo enviado

with zipfile.ZipFile(io.BytesIO(uploaded[zip_filename]), 'r') as zip_ref:
    zip_ref.extractall('.')  # Extrai todos os arquivos para a pasta atual
    print("Arquivos extraídos:")
    print(zip_ref.namelist())  # Mostra lista de arquivos no ZIP

# 3. VERIFICAR NOMES EXATOS DOS ARQUIVOS (Importante!)
# Os nomes podem variar dependendo da fonte do dataset
print("\nArquivos disponíveis após extração:")
!ls -l

# 4. CARREGAR OS DATASETS (com nomes corrigidos)
try:
    orders = pd.read_csv('olist_orders_dataset.csv')  # Nome padrão
except FileNotFoundError:
    # Tentar variações comuns de nomes
    orders = pd.read_csv('orders.csv')  # Nome alternativo

# Repetir para outros arquivos
order_items = pd.read_csv('olist_order_items_dataset.csv')  # ou 'order_items.csv'
products = pd.read_csv('olist_products_dataset.csv')  # ou 'products.csv'
customers = pd.read_csv('olist_customers_dataset.csv')  # ou 'customers.csv'

# 5. VERIFICAÇÃO DE CARREGAMENTO
print("\nPrimeiras linhas de cada dataset:")
print("Pedidos:", orders.shape, orders.columns.tolist())
print("Itens:", order_items.shape, order_items.columns.tolist())
print("Produtos:", products.shape, products.columns.tolist())
print("Clientes:", customers.shape, customers.columns.tolist())

# 1.2.1 - JUNÇÃO DAS TABELAS PRINCIPAIS
# --------------------------------------
# Unir itens de pedido com informações de produtos
order_items_with_products = order_items.merge(
    products[['product_id', 'product_category_name']],  # Selecionar apenas colunas necessárias
    on='product_id',
    how='left'
)

# Verificar resultado
print("Itens de pedido com categorias:")
print(order_items_with_products.head(3))
print(f"\nTotal de linhas: {len(order_items_with_products)}")
print(f"Colunas disponíveis: {order_items_with_products.columns.tolist()}")

# 1.2.2 - ADICIONAR INFORMAÇÕES DE PEDIDOS
# ----------------------------------------
full_data = order_items_with_products.merge(
    orders[['order_id', 'customer_id', 'order_status', 'order_purchase_timestamp']],
    on='order_id',
    how='left'
)

# 1.2.3 - ADICIONAR DADOS DE CLIENTES
# -----------------------------------
full_data = full_data.merge(
    customers[['customer_id', 'customer_state']],
    on='customer_id',
    how='left'
)

# Verificação final
print("\nDataset completo:")
print(full_data.head(3))
print(f"\nTotal de linhas final: {len(full_data)}")
print(f"Colunas disponíveis: {full_data.columns.tolist()}")

# 1.2.4 - TRATAMENTO DE VALORES AUSENTES
# --------------------------------------
# Preencher categorias não informadas
full_data['product_category_name'] = full_data['product_category_name'].fillna('nao_informado')

# Verificar nulos
print("\nValores nulos por coluna:")
print(full_data.isnull().sum())

# Converter datas
full_data['order_purchase_timestamp'] = pd.to_datetime(full_data['order_purchase_timestamp'])

# Criar colunas derivadas
full_data['purchase_month'] = full_data['order_purchase_timestamp'].dt.to_period('M')
full_data['total_price'] = full_data['price'] + full_data['freight_value']

# Tratar categorias ausentes
full_data['product_category_name'] = full_data['product_category_name'].fillna('nao_informado')

# Verificar resultado
print(full_data.head(3))

# Exportar dados unificados
full_data.to_csv('olist_full_data.csv', index=False)

# Baixar arquivo
files.download('olist_full_data.csv')